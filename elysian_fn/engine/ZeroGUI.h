
#define Col_AliceBlue { 0.941176534f, 0.972549081f, 1.000000000f, 1.000000000f }
#define Col_AntiqueWhite { 0.980392218f, 0.921568692f, 0.843137324f, 1.000000000f }
#define Col_Aqua { 0.000000000f, 1.000000000f, 1.000000000f, 1.000000000f }
#define Col_Aquamarine { 0.498039246f, 1.000000000f, 0.831372619f, 1.000000000f }
#define Col_Azure { 0.941176534f, 1.000000000f, 1.000000000f, 1.000000000f }
#define Col_Beige { 0.960784376f, 0.960784376f, 0.862745166f, 1.000000000f }
#define Col_Bisque { 1.000000000f, 0.894117713f, 0.768627524f, 1.000000000f }
#define Col_Black { 0.000000000f, 0.000000000f, 0.000000000f, 1.000000000f }
#define Col_BlanchedAlmond { 1.000000000f, 0.921568692f, 0.803921640f, 1.000000000f }
#define Col_Blue { 0.000000000f, 0.000000000f, 1.000000000f, 1.000000000f }
#define Col_BlueViolet { 0.541176498f, 0.168627456f, 0.886274576f, 1.000000000f }
#define Col_Brown { 0.647058845f, 0.164705887f, 0.164705887f, 1.000000000f }
#define Col_BurlyWood { 0.870588303f, 0.721568644f, 0.529411793f, 1.000000000f }
#define Col_CadetBlue { 0.372549027f, 0.619607866f, 0.627451003f, 1.000000000f }
#define Col_Chartreuse { 0.498039246f, 1.000000000f, 0.000000000f, 1.000000000f }
#define Col_Chocolate { 0.823529482f, 0.411764741f, 0.117647067f, 1.000000000f }
#define Col_Coral { 1.000000000f, 0.498039246f, 0.313725501f, 1.000000000f }
#define Col_CornflowerBlue { 0.392156899f, 0.584313750f, 0.929411829f, 1.000000000f }
#define Col_Cornsilk { 1.000000000f, 0.972549081f, 0.862745166f, 1.000000000f }
#define Col_Crimson { 0.862745166f, 0.078431375f, 0.235294133f, 1.000000000f }
#define Col_Cyan { 0.000000000f, 1.000000000f, 1.000000000f, 1.000000000f }
#define Col_DarkBlue { 0.000000000f, 0.000000000f, 0.545098066f, 1.000000000f }
#define Col_DarkCyan { 0.000000000f, 0.545098066f, 0.545098066f, 1.000000000f }
#define Col_DarkGoldenrod { 0.721568644f, 0.525490224f, 0.043137256f, 1.000000000f }
#define Col_DarkGray { 0.662745118f, 0.662745118f, 0.662745118f, 1.000000000f }
#define Col_DarkGreen { 0.000000000f, 0.392156899f, 0.000000000f, 1.000000000f }
#define Col_DarkKhaki { 0.741176486f, 0.717647076f, 0.419607878f, 1.000000000f }
#define Col_DarkMagenta { 0.545098066f, 0.000000000f, 0.545098066f, 1.000000000f }
#define Col_DarkOliveGreen { 0.333333343f, 0.419607878f, 0.184313729f, 1.000000000f }
#define Col_DarkOrange { 1.000000000f, 0.549019635f, 0.000000000f, 1.000000000f }
#define Col_DarkOrchid { 0.600000024f, 0.196078449f, 0.800000072f, 1.000000000f }
#define Col_DarkRed { 0.545098066f, 0.000000000f, 0.000000000f, 1.000000000f }
#define Col_DarkSalmon { 0.913725555f, 0.588235319f, 0.478431404f, 1.000000000f }
#define Col_DarkSeaGreen { 0.560784340f, 0.737254918f, 0.545098066f, 1.000000000f }
#define Col_DarkSlateBlue { 0.282352954f, 0.239215702f, 0.545098066f, 1.000000000f }
#define Col_DarkSlateGray { 0.184313729f, 0.309803933f, 0.309803933f, 1.000000000f }
#define Col_DarkTurquoise { 0.000000000f, 0.807843208f, 0.819607913f, 1.000000000f }
#define Col_DarkViolet { 0.580392182f, 0.000000000f, 0.827451050f, 1.000000000f }
#define Col_DeepPink { 1.000000000f, 0.078431375f, 0.576470613f, 1.000000000f }
#define Col_DeepSkyBlue { 0.000000000f, 0.749019623f, 1.000000000f, 1.000000000f }
#define Col_DimGray { 0.411764741f, 0.411764741f, 0.411764741f, 1.000000000f }
#define Col_DodgerBlue { 0.117647067f, 0.564705908f, 1.000000000f, 1.000000000f }
#define Col_Firebrick { 0.698039234f, 0.133333340f, 0.133333340f, 1.000000000f }
#define Col_FloralWhite { 1.000000000f, 0.980392218f, 0.941176534f, 1.000000000f }
#define Col_ForestGreen { 0.133333340f, 0.545098066f, 0.133333340f, 1.000000000f }
#define Col_Fuchsia { 1.000000000f, 0.000000000f, 1.000000000f, 1.000000000f }
#define Col_Gainsboro { 0.862745166f, 0.862745166f, 0.862745166f, 1.000000000f }
#define Col_GhostWhite { 0.972549081f, 0.972549081f, 1.000000000f, 1.000000000f }
#define Col_Gold { 1.000000000f, 0.843137324f, 0.000000000f, 1.000000000f }
#define Col_Goldenrod { 0.854902029f, 0.647058845f, 0.125490203f, 1.000000000f }
#define Col_Gray { 0.501960814f, 0.501960814f, 0.501960814f, 1.000000000f }
#define Col_Green { 0.000000000f, 0.501960814f, 0.000000000f, 1.000000000f }
#define Col_GreenYellow { 0.678431392f, 1.000000000f, 0.184313729f, 1.000000000f }
#define Col_Honeydew { 0.941176534f, 1.000000000f, 0.941176534f, 1.000000000f }
#define Col_HotPink { 1.000000000f, 0.411764741f, 0.705882370f, 1.000000000f }
#define Col_IndianRed { 0.803921640f, 0.360784322f, 0.360784322f, 1.000000000f }
#define Col_Indigo { 0.294117659f, 0.000000000f, 0.509803951f, 1.000000000f }
#define Col_Ivory { 1.000000000f, 1.000000000f, 0.941176534f, 1.000000000f }
#define Col_Khaki { 0.941176534f, 0.901960850f, 0.549019635f, 1.000000000f }
#define Col_Lavender { 0.901960850f, 0.901960850f, 0.980392218f, 1.000000000f }
#define Col_LavenderBlush { 1.000000000f, 0.941176534f, 0.960784376f, 1.000000000f }
#define Col_LawnGreen { 0.486274540f, 0.988235354f, 0.000000000f, 1.000000000f }
#define Col_LemonChiffon { 1.000000000f, 0.980392218f, 0.803921640f, 1.000000000f }
#define Col_LightBlue { 0.678431392f, 0.847058892f, 0.901960850f, 1.000000000f }
#define Col_LightCoral { 0.941176534f, 0.501960814f, 0.501960814f, 1.000000000f }
#define Col_LightCyan { 0.878431439f, 1.000000000f, 1.000000000f, 1.000000000f }
#define Col_LightGoldenrodYellow { 0.980392218f, 0.980392218f, 0.823529482f, 1.000000000f }
#define Col_LightGreen { 0.564705908f, 0.933333397f, 0.564705908f, 1.000000000f }
#define Col_LightGray { 0.827451050f, 0.827451050f, 0.827451050f, 1.000000000f }
#define Col_LightPink { 1.000000000f, 0.713725507f, 0.756862819f, 1.000000000f }
#define Col_LightSalmon { 1.000000000f, 0.627451003f, 0.478431404f, 1.000000000f }
#define Col_LightSeaGreen { 0.125490203f, 0.698039234f, 0.666666687f, 1.000000000f }
#define Col_LightSkyBlue { 0.529411793f, 0.807843208f, 0.980392218f, 1.000000000f }
#define Col_LightSlateGray { 0.466666698f, 0.533333361f, 0.600000024f, 1.000000000f }
#define Col_LightSteelBlue { 0.690196097f, 0.768627524f, 0.870588303f, 1.000000000f }
#define Col_LightYellow { 1.000000000f, 1.000000000f, 0.878431439f, 1.000000000f }
#define Col_Lime { 0.000000000f, 1.000000000f, 0.000000000f, 1.000000000f }
#define Col_LimeGreen { 0.196078449f, 0.803921640f, 0.196078449f, 1.000000000f }
#define Col_Linen { 0.980392218f, 0.941176534f, 0.901960850f, 1.000000000f }
#define Col_Magenta { 1.000000000f, 0.000000000f, 1.000000000f, 1.000000000f }
#define Col_Maroon { 0.501960814f, 0.000000000f, 0.000000000f, 1.000000000f }
#define Col_MediumAquamarine { 0.400000036f, 0.803921640f, 0.666666687f, 1.000000000f }
#define Col_MediumBlue { 0.000000000f, 0.000000000f, 0.803921640f, 1.000000000f }
#define Col_MediumOrchid { 0.729411781f, 0.333333343f, 0.827451050f, 1.000000000f }
#define Col_MediumPurple { 0.576470613f, 0.439215720f, 0.858823597f, 1.000000000f }
#define Col_MediumSeaGreen { 0.235294133f, 0.701960802f, 0.443137288f, 1.000000000f }
#define Col_MediumSlateBlue { 0.482352972f, 0.407843173f, 0.933333397f, 1.000000000f }
#define Col_MediumSpringGreen { 0.000000000f, 0.980392218f, 0.603921592f, 1.000000000f }
#define Col_MediumTurquoise { 0.282352954f, 0.819607913f, 0.800000072f, 1.000000000f }
#define Col_MediumVioletRed { 0.780392230f, 0.082352944f, 0.521568656f, 1.000000000f }
#define Col_MidnightBlue { 0.098039225f, 0.098039225f, 0.439215720f, 1.000000000f }
#define Col_MintCream { 0.960784376f, 1.000000000f, 0.980392218f, 1.000000000f }
#define Col_MistyRose { 1.000000000f, 0.894117713f, 0.882353008f, 1.000000000f }
#define Col_Moccasin { 1.000000000f, 0.894117713f, 0.709803939f, 1.000000000f }
#define Col_NavajoWhite { 1.000000000f, 0.870588303f, 0.678431392f, 1.000000000f }
#define Col_Navy { 0.000000000f, 0.000000000f, 0.501960814f, 1.000000000f }
#define Col_OldLace { 0.992156923f, 0.960784376f, 0.901960850f, 1.000000000f }
#define Col_Olive { 0.501960814f, 0.501960814f, 0.000000000f, 1.000000000f }
#define Col_OliveDrab { 0.419607878f, 0.556862772f, 0.137254909f, 1.000000000f }
#define Col_Orange { 1.000000000f, 0.647058845f, 0.000000000f, 1.000000000f }
#define Col_OrangeRed { 1.000000000f, 0.270588249f, 0.000000000f, 1.000000000f }
#define Col_Orchid { 0.854902029f, 0.439215720f, 0.839215755f, 1.000000000f }
#define Col_PaleGoldenrod { 0.933333397f, 0.909803987f, 0.666666687f, 1.000000000f }
#define Col_PaleGreen { 0.596078455f, 0.984313786f, 0.596078455f, 1.000000000f }
#define Col_PaleTurquoise { 0.686274529f, 0.933333397f, 0.933333397f, 1.000000000f }
#define Col_PaleVioletRed { 0.858823597f, 0.439215720f, 0.576470613f, 1.000000000f }
#define Col_PapayaWhip { 1.000000000f, 0.937254965f, 0.835294187f, 1.000000000f }
#define Col_PeachPuff { 1.000000000f, 0.854902029f, 0.725490212f, 1.000000000f }
#define Col_Peru { 0.803921640f, 0.521568656f, 0.247058839f, 1.000000000f }
#define Col_Pink { 1.000000000f, 0.752941251f, 0.796078503f, 1.000000000f }
#define Col_Plum { 0.866666734f, 0.627451003f, 0.866666734f, 1.000000000f }
#define Col_PowderBlue { 0.690196097f, 0.878431439f, 0.901960850f, 1.000000000f }
#define Col_Purple { 0.501960814f, 0.000000000f, 0.501960814f, 1.000000000f }
#define Col_Red { 1.000000000f, 0.000000000f, 0.000000000f, 1.000000000f }
#define Col_RosyBrown { 0.737254918f, 0.560784340f, 0.560784340f, 1.000000000f }
#define Col_RoyalBlue { 0.254901975f, 0.411764741f, 0.882353008f, 1.000000000f }
#define Col_SaddleBrown { 0.545098066f, 0.270588249f, 0.074509807f, 1.000000000f }
#define Col_Salmon { 0.980392218f, 0.501960814f, 0.447058856f, 1.000000000f }
#define Col_SandyBrown { 0.956862807f, 0.643137276f, 0.376470625f, 1.000000000f }
#define Col_SeaGreen { 0.180392161f, 0.545098066f, 0.341176480f, 1.000000000f }
#define Col_SeaShell { 1.000000000f, 0.960784376f, 0.933333397f, 1.000000000f }
#define Col_Sienna { 0.627451003f, 0.321568638f, 0.176470593f, 1.000000000f }
#define Col_Silver { 0.752941251f, 0.752941251f, 0.752941251f, 1.000000000f }
#define Col_SkyBlue { 0.529411793f, 0.807843208f, 0.921568692f, 1.000000000f }
#define Col_SlateBlue { 0.415686309f, 0.352941185f, 0.803921640f, 1.000000000f }
#define Col_SlateGray { 0.439215720f, 0.501960814f, 0.564705908f, 1.000000000f }
#define Col_Snow { 1.000000000f, 0.980392218f, 0.980392218f, 1.000000000f }
#define Col_SpringGreen { 0.000000000f, 1.000000000f, 0.498039246f, 1.000000000f }
#define Col_SteelBlue { 0.274509817f, 0.509803951f, 0.705882370f, 1.000000000f }
#define Col_Tan { 0.823529482f, 0.705882370f, 0.549019635f, 1.000000000f }
#define Col_Teal { 0.000000000f, 0.501960814f, 0.501960814f, 1.000000000f }
#define Col_Thistle { 0.847058892f, 0.749019623f, 0.847058892f, 1.000000000f }
#define Col_Tomato { 1.000000000f, 0.388235331f, 0.278431386f, 1.000000000f }
#define Col_Transparent { 0.000000000f, 0.000000000f, 0.000000000f, 0.000000000f }
#define Col_Turquoise { 0.250980407f, 0.878431439f, 0.815686345f, 1.000000000f }
#define Col_Violet { 0.933333397f, 0.509803951f, 0.933333397f, 1.000000000f }
#define Col_Wheat { 0.960784376f, 0.870588303f, 0.701960802f, 1.000000000f }
#define Col_White { 1.000000000f, 1.000000000f, 1.0f, 1.000000000f }
#define Col_WhiteSmoke { 0.960784376f, 0.960784376f, 0.960784376f, 1.000000000f }
#define Col_Yellow { 1.000000000f, 1.000000000f, 0.000000000f, 1.000000000f }
#define Col_YellowGreen { 0.603921592f, 0.803921640f, 0.196078449f, 1.000000000f }

namespace ZeroGUI
{
	namespace Colors
	{
		flinearcolor Text = { 1.0f, 1.0f, 1.0f, 1.0f };
		flinearcolor Text_Shadow { 0.0f, 0.0f, 0.0f, 0.0f };
		flinearcolor Text_Outline { 0.0f, 0.0f, 0.0f, 0.30f };

		flinearcolor Window_Background { 0.009f, 0.009f, 0.009f, 1.0f };
		flinearcolor Window_Header { 0.10f, 0.15f, 0.84f, 1.0f };

		flinearcolor Button_Idle { 0.10f, 0.15f, 0.84f, 1.0f };
		flinearcolor Button_Hovered { 0.15f, 0.20f, 0.89f, 1.0f };
		flinearcolor Button_Active { 0.20f, 0.25f, 0.94f, 1.0f };

		flinearcolor Checkbox_Idle { 0.17f, 0.16f, 0.23f, 1.0f };
		flinearcolor Checkbox_Hovered { 0.22f, 0.30f, 0.72f, 1.0f };
		flinearcolor Checkbox_Enabled { 0.20f, 0.25f, 0.94f, 1.0f };

		flinearcolor Combobox_Idle { 0.17f, 0.16f, 0.23f, 1.0f };
		flinearcolor Combobox_Hovered { 0.17f, 0.16f, 0.23f, 1.0f };
		flinearcolor Combobox_Elements { 0.239f, 0.42f, 0.82f, 1.0f };

		flinearcolor Slider_Idle { 0.17f, 0.16f, 0.23f, 1.0f };
		flinearcolor Slider_Hovered { 0.17f, 0.16f, 0.23f, 1.0f };
		flinearcolor Slider_Progress { 0.22f, 0.30f, 0.72f, 1.0f };
		flinearcolor Slider_Button { 0.10f, 0.15f, 0.84f, 1.0f };

		flinearcolor ColorPicker_Background { 0.006f, 0.006f, 0.006f, 1.0f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			fvector2d pos;
			fvector2d size;
			flinearcolor color;
			const char* name;
			bool outline;

			fvector2d from;
			fvector2d to;
			int thickness;
		};
		DrawList drawlist [ 128 ];

		void drawFilledRect( fvector2d pos, float w, float h, flinearcolor color )
		{
			for ( int i = 0; i < 128; i++ )
			{
				if ( drawlist [ i ].type == -1 )
				{
					drawlist [ i ].type = 1;
					drawlist [ i ].pos = pos;
					drawlist [ i ].size = fvector2d { w, h };
					drawlist [ i ].color = color;
					return;
				}
			}
		}
		void TextLeft( const char* name, fvector2d pos, flinearcolor color, bool outline )
		{
			for ( int i = 0; i < 128; i++ )
			{
				if ( drawlist [ i ].type == -1 )
				{
					drawlist [ i ].type = 2;
					drawlist [ i ].name = name;
					drawlist [ i ].pos = pos;
					drawlist [ i ].outline = outline;
					drawlist [ i ].color = color;
					return;
				}
			}
		}
		void TextCenter( const char* name, fvector2d pos, flinearcolor color, bool outline )
		{
			for ( int i = 0; i < 128; i++ )
			{
				if ( drawlist [ i ].type == -1 )
				{
					drawlist [ i ].type = 3;
					drawlist [ i ].name = name;
					drawlist [ i ].pos = pos;
					drawlist [ i ].outline = outline;
					drawlist [ i ].color = color;
					return;
				}
			}
		}
		void Draw_Line( fvector2d from, fvector2d to, int thickness, flinearcolor color )
		{
			for ( int i = 0; i < 128; i++ )
			{
				if ( drawlist [ i ].type == -1 )
				{
					drawlist [ i ].type = 4;
					drawlist [ i ].from = from;
					drawlist [ i ].to = to;
					drawlist [ i ].thickness = thickness;
					drawlist [ i ].color = color;
					return;
				}
			}
		}
	}

	ucanvas* canvas;
	wchar_t* s2wc( const char* c )
	{
		const size_t cSize = IFH(strlen)( c ) + 1;
		wchar_t* wc = new wchar_t [ cSize ];
		IFH(mbstowcs)( wc, c, cSize );

		return wc;
	}

	bool hover_element = false;
	fvector2d menu_pos = fvector2d { 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	fvector2d first_element_pos = fvector2d { 0, 0 };

	fvector2d last_element_pos = fvector2d { 0, 0 };
	fvector2d last_element_size = fvector2d { 0, 0 };

	int current_element = -1;
	fvector2d current_element_pos = fvector2d { 0, 0 };
	fvector2d current_element_size = fvector2d { 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas( ucanvas* _canvas )
	{
		canvas = _canvas;
	}

	fvector2d CursorPos( )
	{
		POINT cursorPos;
		IFH(GetCursorPos)( &cursorPos );
		return fvector2d { ( float ) cursorPos.x, ( float ) cursorPos.y };
	}
	bool MouseInZone( fvector2d pos, fvector2d size )
	{
		fvector2d cursor_pos = CursorPos( );

		if ( cursor_pos.x > pos.x && cursor_pos.y > pos.y )
			if ( cursor_pos.x < pos.x + size.x && cursor_pos.y < pos.y + size.y )
				return true;

		return false;
	}

	void Draw_Cursor( bool toogle )
	{
		if ( toogle )
		{
			fvector2d cursorPos = CursorPos( );
			canvas->k2_drawline( fvector2d { cursorPos.x, cursorPos.y }, fvector2d { cursorPos.x + 35, cursorPos.y + 10 }, 1, flinearcolor { 0.30f, 0.30f, 0.80f, 1.0f } );


			int x = 35;
			int y = 10;
			while ( y != 30 ) //20 steps
			{
				x -= 1; if ( x < 15 ) x = 15;
				y += 1; if ( y > 30 ) y = 30;

				canvas->k2_drawline( fvector2d { cursorPos.x, cursorPos.y }, fvector2d { cursorPos.x + x, cursorPos.y + y }, 1, flinearcolor { 0.30f, 0.30f, 0.80f, 1.0f } );
			}

			canvas->k2_drawline( fvector2d { cursorPos.x, cursorPos.y }, fvector2d { cursorPos.x + 15, cursorPos.y + 30 }, 1, flinearcolor { 0.30f, 0.30f, 0.80f, 1.0f } );
			canvas->k2_drawline( fvector2d { cursorPos.x + 35, cursorPos.y + 10 }, fvector2d { cursorPos.x + 15, cursorPos.y + 30 }, 1, flinearcolor { 0.30f, 0.30f, 0.80f, 1.0f } );
		}
	}

	void SameLine( )
	{
		sameLine = true;
	}
	void PushNextElementY( float y, bool from_last_element = true )
	{
		pushY = true;
		if ( from_last_element )
			pushYvalue = last_element_pos.y + last_element_size.y + y;
		else
			pushYvalue = y;
	}
	void NextColumn( float x )
	{
		offset_x = x;
		PushNextElementY( first_element_pos.y, false );
	}
	void ClearFirstPos( )
	{
		first_element_pos = fvector2d { 0, 0 };
	}

	void TextLeft( const char* name, fvector2d pos, flinearcolor color, bool outline )
	{
		int length = IFH(strlen)( name ) + 1;
		canvas->k2_drawtext( elysian_fn::sdk::classes::defines::font, fstring { s2wc( name ) }, pos, fvector2d { 0.97f, 0.97f }, color, false, Colors::Text_Shadow, fvector2d { pos.x + 1, pos.y + 1 }, false, true, true, Colors::Text_Outline );
	}
	void TextCenter( const char* name, fvector2d pos, flinearcolor color, bool outline )
	{
		int length = IFH(strlen)( name ) + 1;
		canvas->k2_drawtext( elysian_fn::sdk::classes::defines::font, fstring { s2wc( name ) }, pos, fvector2d { 0.97f, 0.97f }, color, false, Colors::Text_Shadow, fvector2d { pos.x + 1, pos.y + 1 }, true, true, true, Colors::Text_Outline );
	}

	void GetColor( flinearcolor* color, float* r, float* g, float* b, float* a )
	{
		*r = color->red;
		*g = color->green;
		*b = color->blue;
		*a = color->alpha;
	}
	UINT32 GetColorUINT( int r, int g, int b, int a )
	{
		UINT32 result = (BYTE( a ) << 24) + (BYTE( r ) << 16) + (BYTE( g ) << 8) + BYTE( b );
		return result;
	}

	void Draw_Line( fvector2d from, fvector2d to, int thickness, flinearcolor color )
	{
		canvas->k2_drawline( fvector2d { from.x, from.y }, fvector2d { to.x, to.y }, thickness, color );
	}
	void drawFilledRect( fvector2d initial_pos, float w, float h, flinearcolor color )
	{
		for ( float i = 0.0f; i < h; i += 1.0f )
			canvas->k2_drawline( fvector2d { initial_pos.x, initial_pos.y + i }, fvector2d { initial_pos.x + w, initial_pos.y + i }, 1.0f, color );
	}
	void DrawFilledCircle( fvector2d pos, float r, flinearcolor color )
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = ( int ) (2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for ( ; angle < 2 * PI; angle += smooth, i++ )
		{
			Draw_Line( fvector2d { pos.x, pos.y }, fvector2d { pos.x + cosf( angle ) * r, pos.y + sinf( angle ) * r }, 1.0f, color );
		}
	}
	void DrawCircle( fvector2d pos, int radius, int numSides, flinearcolor Color )
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		fvector2d V [ 128 ];
		for ( float a = 0; a < PI * 2.0; a += Step ) {
			float X1 = radius * math::cos( a ) + pos.x;
			float Y1 = radius * math::sin( a ) + pos.y;
			float X2 = radius * math::cos( a + Step ) + pos.x;
			float Y2 = radius * math::sin( a + Step ) + pos.y;
			V [ Count ].x = X1;
			V [ Count ].y = Y1;
			V [ Count + 1 ].x = X2;
			V [ Count + 1 ].y = Y2;
			//Draw_Line(fvector2d{ pos.x, pos.y }, fvector2d{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line( fvector2d { V [ Count ].x, V [ Count ].y }, fvector2d { X2, Y2 }, 1.0f, Color );// Circle Around
		}
	}

	fvector2d dragPos;
	bool Window( const char* name, fvector2d* pos, fvector2d size, bool isOpen )
	{
		elements_count = 0;

		if ( !isOpen )
			return false;

		bool isHovered = MouseInZone( fvector2d { pos->x, pos->y }, size );

		//Drop last element
		if ( current_element != -1 && !IFH(GetAsyncKeyState)( 0x1 ) )
		{
			current_element = -1;
		}

		//Drag
		if ( hover_element && IFH(GetAsyncKeyState)( 0x1 ) )
		{

		}
		else if ( (isHovered || dragPos.x != 0) && !hover_element )
		{
			if ( Input::IsMouseClicked( 0, elements_count, true ) )
			{
				fvector2d cursorPos = CursorPos( );

				cursorPos.x -= size.x;
				cursorPos.y -= size.y;

				if ( dragPos.x == 0 )
				{
					dragPos.x = (cursorPos.x - pos->x);
					dragPos.y = (cursorPos.y - pos->y);
				}
				pos->x = cursorPos.x - dragPos.x;
				pos->y = cursorPos.y - dragPos.y;
			}
			else
			{
				dragPos = fvector2d { 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = fvector2d { pos->x, pos->y };
		first_element_pos = fvector2d { 0, 0 };
		current_element_pos = fvector2d { 0, 0 };
		current_element_size = fvector2d { 0, 0 };

		//Bg
		drawFilledRect( fvector2d { pos->x, pos->y }, size.x, size.y, Colors::Window_Background );
		//drawFilledRect(fvector2d{ pos->x, pos->y }, 122, size.y, flinearcolor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		//Header
		drawFilledRect( fvector2d { pos->x, pos->y }, size.x, 25.0f, Colors::Window_Header );

		offset_y += 25.0f;

		//Title
		fvector2d titlePos = fvector2d { pos->x + size.x / 2, pos->y + 25 / 2 };
		TextCenter( name, titlePos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

		return true;
	}

	void Text( const char* text, bool center = false, bool outline = false )
	{
		elements_count++;

		float size = 25;
		fvector2d padding = fvector2d { 10, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}

		if ( !sameLine )
			offset_y += size + padding.y;

		//Text
		fvector2d textPos = fvector2d { pos.x + 5.0f, pos.y + size / 2 };
		if ( center )
			TextCenter( text, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, outline );
		else
			TextLeft( text, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, outline );

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;
	}
	bool ButtonTab( const char* name, fvector2d size, bool active )
	{
		elements_count++;

		fvector2d padding = fvector2d { 5, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, size );

		//Bg
		if ( active )
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Active );
		}
		else if ( isHovered )
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered );
			hover_element = true;
		}
		else
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Idle );
		}

		if ( !sameLine )
			offset_y += size.y + padding.y;

		//Text
		fvector2d textPos = fvector2d { pos.x + size.x / 2, pos.y + size.y / 2 };
		TextCenter( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;

		if ( isHovered && Input::IsMouseClicked( 0, elements_count, false ) )
			return true;

		return false;
	}
	bool Button( const char* name, fvector2d size )
	{
		elements_count++;

		fvector2d padding = fvector2d { 5, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, size );

		//Bg
		if ( isHovered )
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered );
			hover_element = true;
		}
		else
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Idle );
		}

		if ( !sameLine )
			offset_y += size.y + padding.y;

		//Text
		fvector2d textPos = fvector2d { pos.x + size.x / 2, pos.y + size.y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;

		if ( isHovered && Input::IsMouseClicked( 0, elements_count, false ) )
			return true;

		return false;
	}
	void Checkbox( const char* name, bool* value )
	{
		elements_count++;

		float size = 18;
		fvector2d padding = fvector2d { 10, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, fvector2d { size, size } );

		//Bg
		if ( isHovered )
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size, size, Colors::Checkbox_Hovered );
			hover_element = true;
		}
		else
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size, size, Colors::Checkbox_Idle );
		}

		if ( !sameLine )
			offset_y += size + padding.y;

		if ( *value )
		{
			drawFilledRect( fvector2d { pos.x + 3, pos.y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled );
			//drawFilledRect(fvector2d{ pos.x + 9, pos.y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		fvector2d textPos = fvector2d { pos.x + size + 5.0f, pos.y + size / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;

		if ( isHovered && Input::IsMouseClicked( 0, elements_count, false ) )
			*value = !*value;
	}
	//void SliderInt( const char* name, int* value, int min, int max )
	//{
	//	elements_count++;

	//	fvector2d size = fvector2d { 240, 50 };
	//	fvector2d slider_size = fvector2d { 200, 10 };
	//	fvector2d padding = fvector2d { 10, 15 };
	//	fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
	//	if ( sameLine )
	//	{
	//		pos.x = last_element_pos.x + last_element_size.x + padding.x;
	//		pos.y = last_element_pos.y;
	//	}
	//	if ( pushY )
	//	{
	//		pos.y = pushYvalue;
	//		pushY = false;
	//		pushYvalue = 0.0f;
	//		offset_y = pos.y - menu_pos.y;
	//	}
	//	bool isHovered = MouseInZone( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size );

	//	if ( !sameLine )
	//		offset_y += size.y + padding.y;

	//	//Bg
	//	if ( isHovered || current_element == elements_count )
	//	{
	//		//Drag
	//		if ( Input::IsMouseClicked( 0, elements_count, true ) )
	//		{
	//			current_element = elements_count;

	//			fvector2d cursorPos = CursorPos( );
	//			*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
	//			if ( *value < min ) *value = min;
	//			if ( *value > max ) *value = max;
	//		}

	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered );
	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress );

	//		hover_element = true;
	//	}
	//	else
	//	{
	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle );
	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress );
	//	}


	//	//Value
	//	float oneP = slider_size.x / (max - min);
	//	drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress );
	//	//drawFilledRect(fvector2d{ pos.x + oneP * (*value - min) - 10.0f, pos.y + slider_size.y - 5.0f + padding.y }, 20.0f, 20.0f, Colors::Slider_Button);
	//	DrawFilledCircle( fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 10.0f, Colors::Slider_Button );
	//	DrawFilledCircle( fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 5.0f, Colors::Slider_Progress );

	//	char buffer [ 32 ];
	//	sprintf_s( buffer, "%i", *value );
	//	fvector2d valuePos = fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 25 + padding.y };
	//	TextCenter( buffer, valuePos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

	//	//Text
	//	fvector2d textPos = fvector2d { pos.x + 5, pos.y + 10 };
	//	TextLeft( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );


	//	sameLine = false;
	//	last_element_pos = pos;
	//	last_element_size = size;
	//	if ( first_element_pos.x == 0.0f )
	//		first_element_pos = pos;
	//}
	void SliderFloat( const char* name, float* value, float min, float max, const char* format = "%.0f" )
	{
		elements_count++;

		fvector2d size = fvector2d { 210, 40 };
		fvector2d slider_size = fvector2d { 170, 7 };
		fvector2d adjust_zone = fvector2d { 0, 20 };
		fvector2d padding = fvector2d { 10, 15 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y + slider_size.y + padding.y - adjust_zone.y }, fvector2d { slider_size.x, slider_size.y + adjust_zone.y * 1.5f } );

		if ( !sameLine )
			offset_y += size.y + padding.y;

		//Bg
		if ( isHovered || current_element == elements_count )
		{
			//Drag
			if ( Input::IsMouseClicked( 0, elements_count, true ) )
			{
				current_element = elements_count;

				fvector2d cursorPos = CursorPos( );
				*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
				if ( *value < min ) *value = min;
				if ( *value > max ) *value = max;
			}

			drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered );
			DrawFilledCircle( fvector2d { pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress );
			DrawFilledCircle( fvector2d { pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Hovered );

			hover_element = true;
		}
		else
		{
			drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle );
			DrawFilledCircle( fvector2d { pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress );
			DrawFilledCircle( fvector2d { pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Idle );
		}


		//Text
		fvector2d textPos = fvector2d { pos.x, pos.y + 5 };
		TextLeft( name, textPos, Colors::Text, false );

		//Value
		float oneP = slider_size.x / (max - min);
		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress );
		DrawFilledCircle( fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y }, 8.0f, Colors::Slider_Button );
		DrawFilledCircle( fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y }, 4.0f, Colors::Slider_Progress );

		char buffer [ 32 ];
		sprintf_s( buffer, format, *value );
		fvector2d valuePos = fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 20 + padding.y };
		TextCenter( buffer, valuePos, Colors::Text, false );


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;
	}



	bool checkbox_enabled [ 256 ];
	void Combobox( const char* name, fvector2d size, int* value, const char* arg, ... )
	{
		elements_count++;

		fvector2d padding = fvector2d { 5, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, size );

		//Bg
		if ( isHovered || checkbox_enabled [ elements_count ] )
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Combobox_Hovered );

			hover_element = true;
		}
		else
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Combobox_Idle );
		}

		if ( !sameLine )
			offset_y += size.y + padding.y;

		//Text
		fvector2d textPos = fvector2d { pos.x + size.x + 5.0f, pos.y + size.y / 2 };
		TextLeft( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

		//Elements
		bool isHovered2 = false;
		fvector2d element_pos = pos;
		int num = 0;

		if ( checkbox_enabled [ elements_count ] )
		{
			current_element_size.x = element_pos.x - 5.0f;
			current_element_size.y = element_pos.y - 5.0f;
		}
		va_list arguments;
		for ( va_start( arguments, arg ); arg != NULL; arg = va_arg( arguments, const char* ) )
		{
			//Selected Element
			if ( num == *value )
			{
				fvector2d _textPos = fvector2d { pos.x + size.x / 2, pos.y + size.y / 2 };
				TextCenter( ( char* ) arg, _textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );
			}

			if ( checkbox_enabled [ elements_count ] )
			{
				element_pos.y += 25.0f;

				isHovered2 = MouseInZone( fvector2d { element_pos.x, element_pos.y }, fvector2d { size.x, 25.0f } );
				if ( isHovered2 )
				{
					hover_element = true;
					PostRenderer::drawFilledRect( fvector2d { element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Hovered );

					//Click
					if ( Input::IsMouseClicked( 0, elements_count, false ) )
					{
						*value = num;
						checkbox_enabled [ elements_count ] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect( fvector2d { element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Idle );
				}

				PostRenderer::TextLeft( ( char* ) arg, fvector2d { element_pos.x + 5.0f, element_pos.y + 15.0f }, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );
			}
			num++;
		}
		va_end( arguments );
		if ( checkbox_enabled [ elements_count ] )
		{
			current_element_size.x = element_pos.x + 5.0f;
			current_element_size.y = element_pos.y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;

		if ( isHovered && Input::IsMouseClicked( 0, elements_count, false ) )
		{
			checkbox_enabled [ elements_count ] = !checkbox_enabled [ elements_count ];
		}
		if ( !isHovered && !isHovered2 && Input::IsMouseClicked( 0, elements_count, false ) )
		{
			checkbox_enabled [ elements_count ] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString( UCHAR virtualKey )
	{
		UINT scanCode = MapVirtualKey( virtualKey, MAPVK_VK_TO_VSC );

		if ( virtualKey == VK_LBUTTON )
		{
			return ( "MOUSE0" );
		}
		if ( virtualKey == VK_RBUTTON )
		{
			return ( "MOUSE1" );
		}
		if ( virtualKey == VK_MBUTTON )
		{
			return ( "MBUTTON" );
		}
		if ( virtualKey == VK_XBUTTON1 )
		{
			return ( "XBUTTON1" );
		}
		if ( virtualKey == VK_XBUTTON2 )
		{
			return ( "XBUTTON2" );
		}

		CHAR szName [ 128 ];
		int result = 0;
		switch ( virtualKey )
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = IFH(GetKeyNameTextA)( scanCode << 16, szName, 128 );
		}

		return szName;
	}
	void Hotkey( const char* name, fvector2d size, int* key )
	{
		elements_count++;

		fvector2d padding = fvector2d { 5, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y + (last_element_size.y / 2) - size.y / 2;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, size );

		//Bg
		if ( isHovered )
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered );
			hover_element = true;
		}
		else
		{
			drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, Colors::Button_Idle );
		}

		if ( !sameLine )
			offset_y += size.y + padding.y;

		if ( active_hotkey == elements_count )
		{
			//Text
			fvector2d textPos = fvector2d { pos.x + size.x / 2, pos.y + size.y / 2 };
			TextCenter( "[Press Key]", textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

			if ( !ZeroGUI::Input::IsAnyMouseDown( ) )
			{
				already_pressed = false;
			}

			if ( !already_pressed )
			{
				for ( int code = 0; code < 255; code++ )
				{
					if ( IFH(GetAsyncKeyState)( code ) )
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			fvector2d textPos = fvector2d { pos.x + size.x / 2, pos.y + size.y / 2 };
			TextCenter( ( char* ) VirtualKeyCodeToString( *key ).c_str( ), textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

			if ( isHovered )
			{
				if ( Input::IsMouseClicked( 0, elements_count, false ) )
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for ( int code = 0; code < 255; code++ )
						if ( IFH(GetAsyncKeyState)( code ) ) { }
				}
			}
			else
			{
				if ( Input::IsMouseClicked( 0, elements_count, false ) )
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;
	}

	int active_picker = -1;
	flinearcolor saved_color;
	bool ColorPixel( fvector2d pos, fvector2d size, flinearcolor* original, flinearcolor color )
	{
		PostRenderer::drawFilledRect( fvector2d { pos.x, pos.y }, size.x, size.y, color );

		//Выбранный цвет
		if ( original->red == color.red && original->green == color.green && original->blue == color.blue )
		{
			PostRenderer::Draw_Line( fvector2d { pos.x, pos.y }, fvector2d { pos.x + size.x - 1, pos.y }, 1.0f, flinearcolor { 0.0f, 0.0f, 0.0f, 1.0f } );
			PostRenderer::Draw_Line( fvector2d { pos.x, pos.y + size.y - 1 }, fvector2d { pos.x + size.x - 1, pos.y + size.y - 1 }, 1.0f, flinearcolor { 0.0f, 0.0f, 0.0f, 1.0f } );
			PostRenderer::Draw_Line( fvector2d { pos.x, pos.y }, fvector2d { pos.x, pos.y + size.y - 1 }, 1.0f, flinearcolor { 0.0f, 0.0f, 0.0f, 1.0f } );
			PostRenderer::Draw_Line( fvector2d { pos.x + size.x - 1, pos.y }, fvector2d { pos.x + size.x - 1, pos.y + size.y - 1 }, 1.0f, flinearcolor { 0.0f, 0.0f, 0.0f, 1.0f } );
		}

		//Смена цвета
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, size );
		if ( isHovered )
		{
			if ( Input::IsMouseClicked( 0, elements_count, false ) )
				*original = color;
		}

		return true;
	}
	void ColorPicker( const char* name, flinearcolor* color )
	{
		elements_count++;

		float size = 25;
		fvector2d padding = fvector2d { 10, 10 };
		fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if ( sameLine )
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if ( pushY )
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone( fvector2d { pos.x, pos.y }, fvector2d { size, size } );

		if ( !sameLine )
			offset_y += size + padding.y;

		if ( active_picker == elements_count )
		{
			hover_element = true;

			float sizePickerX = 250;
			float sizePickerY = 250;
			bool isHoveredPicker = MouseInZone( fvector2d { pos.x, pos.y }, fvector2d { sizePickerX, sizePickerY - 60 } );

			//Background
			PostRenderer::drawFilledRect( fvector2d { pos.x, pos.y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background );

			//float pixedSize = sizePickerY / pixels;
			//flinearcolor temp_color{1.0f, 1.0f, 1.0f, 1.0f};
			//float iterator = 0.0f;
			//
			//for (int y = 0; y < pixels; y++)
			//{
			//	for (int x = 0; x < pixels; x++)
			//	{
			//		ColorPixel(fvector2d{ pos.x + pixedSize * x, pos.y + pixedSize * y }, pixedSize, color, temp_color);
			//		temp_color.R -= (1.0f - saved_color.R) / pixels;
			//		temp_color.G -= (1.0f - saved_color.G) / pixels;
			//		temp_color.B -= (1.0f - saved_color.B) / pixels;
			//	}
			//	
			//	iterator += 1.0f / pixels;
			//	temp_color = flinearcolor{ 1.0f - iterator, 1.0f - iterator, 1.0f - iterator, 1.0f };
			//}

			fvector2d pixelSize = fvector2d { sizePickerX / 12, sizePickerY / 12 };

			//0
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f } );
			}
			//1
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f } );
			}
			//2
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f } );
			}
			//3
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f } );
			}
			//4
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f } );
			}
			//5
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f } );
			}
			//6
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f } );
			}
			//7
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f } );
			}
			//8
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f } );
			}
			//9
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f } );
			}
			//10
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f } );
			}
			//11
			{
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 0 }, pixelSize, color, flinearcolor { 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 1 }, pixelSize, color, flinearcolor { 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 2 }, pixelSize, color, flinearcolor { 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 3 }, pixelSize, color, flinearcolor { 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 4 }, pixelSize, color, flinearcolor { 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 5 }, pixelSize, color, flinearcolor { 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 6 }, pixelSize, color, flinearcolor { 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 7 }, pixelSize, color, flinearcolor { 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f } );
				ColorPixel( fvector2d { pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 8 }, pixelSize, color, flinearcolor { 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f } );
			}



			if ( isHoveredPicker )
			{
				if ( Input::IsMouseClicked( 0, elements_count, false ) )
				{

				}
			}
			else
			{
				if ( Input::IsMouseClicked( 0, elements_count, false ) )
				{
					active_picker = -1;
					//hover_element = false;
				}
			}
		}
		else
		{
			//Bg
			if ( isHovered )
			{
				drawFilledRect( fvector2d { pos.x, pos.y }, size, size, Colors::Checkbox_Hovered );
				hover_element = true;
			}
			else
			{
				drawFilledRect( fvector2d { pos.x, pos.y }, size, size, Colors::Checkbox_Idle );
			}

			//Color
			drawFilledRect( fvector2d { pos.x + 4, pos.y + 4 }, size - 8, size - 8, *color );

			//Text
			fvector2d textPos = fvector2d { pos.x + size + 5.0f, pos.y + size / 2 };
			TextLeft( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

			if ( isHovered && Input::IsMouseClicked( 0, elements_count, false ) )
			{
				saved_color = *color;
				active_picker = elements_count;
			}
		}


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if ( first_element_pos.x == 0.0f )
			first_element_pos = pos;
	}


	void Render( )
	{
		for ( int i = 0; i < 128; i++ )
		{
			if ( PostRenderer::drawlist [ i ].type != -1 )
			{
				//Filled Rect
				if ( PostRenderer::drawlist [ i ].type == 1 )
				{
					ZeroGUI::drawFilledRect( PostRenderer::drawlist [ i ].pos, PostRenderer::drawlist [ i ].size.x, PostRenderer::drawlist [ i ].size.y, PostRenderer::drawlist [ i ].color );
				}
				//TextLeft
				else if ( PostRenderer::drawlist [ i ].type == 2 )
				{
					ZeroGUI::TextLeft( PostRenderer::drawlist [ i ].name, PostRenderer::drawlist [ i ].pos, PostRenderer::drawlist [ i ].color, PostRenderer::drawlist [ i ].outline );
				}
				//TextCenter
				else if ( PostRenderer::drawlist [ i ].type == 3 )
				{
					ZeroGUI::TextCenter( PostRenderer::drawlist [ i ].name, PostRenderer::drawlist [ i ].pos, PostRenderer::drawlist [ i ].color, PostRenderer::drawlist [ i ].outline );
				}
				//Draw_Line
				else if ( PostRenderer::drawlist [ i ].type == 4 )
				{
					Draw_Line( PostRenderer::drawlist [ i ].from, PostRenderer::drawlist [ i ].to, PostRenderer::drawlist [ i ].thickness, PostRenderer::drawlist [ i ].color );
				}

				PostRenderer::drawlist [ i ].type = -1;
			}
		}
	}
}